# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

Correlationc <- function(coordsx, coordsy, theta, matern, same) {
    .Call(`_spSeparable_Correlationc`, coordsx, coordsy, theta, matern, same)
}

daggp_build <- function(coords, dag, phi, sigmasq, nu, tausq, matern = 1L, num_threads = 1L, prune_dag = FALSE) {
    .Call(`_spSeparable_daggp_build`, coords, dag, phi, sigmasq, nu, tausq, matern, num_threads, prune_dag)
}

#' Fit a Separable Gaussian Process Response Model
#'
#' Implements an adaptive Metropolis-within-Gibbs sampler for the separable
#' multivariate Gaussian process response model.
#' The model assumes
#' \deqn{ \mathrm{vec}(Y) \sim N\left(X \beta, R \otimes \Sigma \right) }
#' where
#' \itemize{
#'   \item \eqn{R} is an \eqn{n \times n} spatial correlation matrix (Matérn),
#'   \item \eqn{\Sigma} is a \eqn{q \times q} cross–covariance matrix across outcomes.
#' }
#'
#' @param Y \eqn{n \times q} data matrix of outcomes, with \eqn{n} spatial sites and \eqn{q} outcomes.
#' @param X Optional \eqn{n \times p} covariate matrix. If provided (\eqn{p > 0}),
#'   the model uses \eqn{Y|\beta, \Sigma \sim MN(X \beta, R_\theta, \Sigma)} and samples \eqn{\beta} by Gibbs.
#'   The prior is \eqn{\beta|\Sigma \sim MN(0_{p \times q}, 1e4 \cdot I_p, \Sigma)} by default.
#' @param coords \eqn{n \times d} matrix of spatial coordinates for the \eqn{n} sites.
#' @param custom_dag Field of index vectors defining the Vecchia approximation
#'   DAG structure for the sites. Use package \code{spiox} for building the DAG.
#' @param theta_start Numeric vector of latent GP hyperparameters
#'   (e.g. range, variance, smoothness, nugget). These are shared across all outcomes
#'   under the separable specification.
#' @param sampling Logical vector indicating which hyperparameters in \code{theta_start}
#'   are to be updated by MCMC.
#' @param Sigma_start Initial \eqn{q \times q} cross–covariance matrix \eqn{\Sigma}.
#' @param mcmc Integer, number of MCMC iterations (default 1000).
#' @param print_every Integer, print progress every this many iterations (default 100).
#' @param dag_opts Integer controlling Vecchia DAG modification:
#'   \itemize{
#'     \item \code{-1}: assume \code{coords} are gridded and DAG was built accordingly,
#'     \item \code{0}: use \code{custom_dag} as provided,
#'     \item \code{>0}: prune the DAG by up to this many neighbors to reduce parent set size.
#'   }
#' @param upd_Sigma Logical, whether to update the cross–covariance matrix \eqn{\Sigma} (default TRUE).
#' @param upd_theta Logical, whether to update GP hyperparameters \eqn{\theta} (default TRUE).
#' @param num_threads Integer, number of OpenMP threads to use (default 1).
#'
#' @return A list with elements:
#' \item{Sigma}{\eqn{q \times q \times mcmc} array of posterior samples of \eqn{\Sigma}.}
#' \item{theta}{Matrix of posterior samples of hyperparameters (rows = parameter, cols = iterations).}
#' \item{dag_cache}{DAG structure used by the Vecchia approximation (for reference).}
#'
#' @details
#' This function constructs a separable multivariate GP model and runs MCMC
#' updates for the spatial hyperparameters and the cross–covariance matrix.
#' Updates for \eqn{\Sigma} are performed via its inverse–Wishart full conditional.
#' Computation can be parallelized using OpenMP if available.
#'
#' @examples
#' \dontrun{
#'   # Example data
#'   n <- 50; q <- 2
#'   coords <- matrix(runif(n*2), n, 2)
#'   Y <- matrix(rnorm(n*q), n, q)
#'   theta_start <- c(1, 1, 0.5, 0.1) # (range, var, smoothness, nugget)
#'   Sigma_start <- diag(q)
#'   custom_dag <- some_dag_constructor(coords)
#'
#'   fit <- spseparable_response(Y, coords, custom_dag,
#'                               theta_start, sampling = c(1,1,1,1),
#'                               Sigma_start, mcmc = 200)
#'   str(fit)
#' }
#'
#' @export
spseparable_response <- function(Y, coords, custom_dag, theta_start, sampling, Sigma_start, X = NULL, mcmc = 1000L, print_every = 100L, dag_opts = 0L, upd_Sigma = TRUE, upd_theta = TRUE, num_threads = 1L) {
    .Call(`_spSeparable_spseparable_response`, Y, coords, custom_dag, theta_start, sampling, Sigma_start, X, mcmc, print_every, dag_opts, upd_Sigma, upd_theta, num_threads)
}

spseparable_logdens <- function(Y, coords, custom_dag, theta, Sigma) {
    .Call(`_spSeparable_spseparable_logdens`, Y, coords, custom_dag, theta, Sigma)
}

